= ADRXXX: Authorization abstraction layer
Felix Hennig <felix.hennig@stackable.tech>
v0.1, 2024-01-18
:status: draft

* Status: {status}
* Deciders: TBD
* Date: 2024-01-18

Technical Story: https://github.com/stackabletech/issues/issues/439

== Problem Statement

How should we design the user facing part of an authorization layer for the platform?
Do we create Custom Resources for some of this, or are ConfigMaps sufficient?
How many, how are the rules split across resources?
Where do users want to "hook in"?
How are policies deployed?

== Context

What is the current state of authorization in the SDP, what do users want to define and which authorization models are widespread already?

=== Current state of authorization and policy in the SDP

Currently the Stackable Data Platform supports authorization policies through OPA.
OPA is a general _policy_ agent and does not out of the box have any particular framework in place for _authorization_ as a special case of policy.
OPA uses policy-as-code to define policy, and as such supports a wide variety of approaches to policy definitions.

Some products do not support OPA yet, but we want to support OPA in them in the future.
Some products like Airflow and Superset do not support OPA and we do not plan to add support at this moment.

The products themselves also have access control models:

* Druid: Uses an RBAC model
* Kafka: RBAC, group based with LDAP, ACLs
* Airflow: Uses roles to group permissions, and then assign roles to users. Roles can also be assigned to LDAP groups.

=== Different authorization models: RBAC, ABAC, ReBAC and more

Out-of-the-box, OPA uses RegoRules to define policies. 
This is very powerful, but also more complex that other mechanisms such as RBAC or ACLs.
We want to pick an authorization model to build on top of OPA and abstract away from the RegoRules for 95% of use cases that the typical Stackable user might encounter.

Role-based access control (RBAC) is a common authorization model where users are assigned roles, and roles come with certain sets of permissions.

Relation-based access control (ReBAC) was popularized by Google Zanzibar and goes beyond RBAC.
The relational model allows for more flexibility when defining rules.

https://www.permit.io/blog/rbac-vs-rebac[RBAC vs. ReBAC].

https://www.keycloak.org/docs/latest/authorization_services/index.html#_overview[The Keycloak model]

Learn more:

* https://authzed.com/zanzibar
* https://authzed.com/blog/what-is-google-zanzibar
* https://gruchalski.com/posts/2022-05-07-zanzibar-style-acls-with-opa-rego/
* https://www.permit.io/blog/oparebac
* https://www.permit.io/blog/policy-engines

== Requirements

The overall design should make it easy for the majority of users to define rules, without needing to write RegoRules.
This should be done with CRDs that can deployed, and it works out of the Box.

For the remaining users it should be possible to hook into various places of the system to write their own more specific rules.

* 80% of users can use the CRDs that allow coarse access control in a unified way across the platform, possibly hiding some product specific things.
* 10% of users can drop down one layer into specifying custom JSON data for the Stackable provided Rego rules, 
  allowing a little bit more detailed access to product specific access control rules such as column masking in Trino.
* 10% of users will want to write completely custom Rego rules, which is currently already possible and will still be supported.

=== Authorization settings that users might want to model

Some use case examples:

* rules for individuals: Alice needs one-of read access to a Trino Table
* group based access control: Bob joins the company in the data science team and should get access to all the resources he needs to stark working
* resource grouping and ad-hoc groups: A new data analysis task force is formed that needs access to specific resources. Resources should be grouped and then all task force members need access.
* group hierarchies: there might be multiple data science teams that share access to some common resources, but also have specific resources that are only relevant to each team.
* Class based permissions: Andy needs to be able to read _all_ Trino tables, and not just a pre-defined selection of tables.

A common complaint seems to be that in RBAC systems, roles end up getting copy pasted. 
A role might have many permissions attached to it, so if you want to modify a particular permission for just one user, you might end up copy-pasting the role.

Also, users should be able to treat resources in general the same way across all supported products.
I.e. there should be an abstraction over resources such as Trino tables, Superset dashboards and Kafka topics.

== Decision Drivers

* The design should be flexible to allow to easily represent various organizational structures.
* It should be possible to group together access to different resources across products.
* The design should validate as much of the input as possible, to prevent misspellings from invalidating rules. Nothing should just silently not do anything.
* Rules should be defined as Manifests and put into Kubernetes.
* Solution needs to be safely implemented. This means that it might be good to keep complexity low. This is a security component!
* Solution needs to work well with existing authorization models in the applications we support.
* Expressive enough so users do not have to copy-paste roles or lists of permissions.

== Constraints

* We use OPA as the underlying policy engine, so any design needs to be implementable with OPA.

== Expected outcome

We should decide on a general authorization model, what we want it to look like to the user and also have a rough idea of how it will be implemented.

== RBAC vs ReBAC

_RBAC_ is the default choice for authorization models, as it is widely known an understood already, and simple to implement and understand.
Kubernetes itself uses RBAC with Role, ClusterRole, RoleBinding etc..

In RBAC it is difficult to give one-of permissions to individual users, since permissions are always assinged to a role, and then the role is assigned to a user.

How are policies actually derived from the relationships in ReBAC?

I think it makes sense to stay close to the applications here, i.e. for druid there should still be read/write permissions on resources.

we still need to define things like "an editor on thsi resource group can write to this topic"

It would be cool to have "resource groups" and then just relations like "owner", "reader", "edtior" relating to a whole group of resources.

A mixed model might make sense, maybe a hierarchical tree of user groups on the one side, and resource groups on the other side? or composing roles and also composing groups, and then mapping groups and roles? I got this idea from Keycloak.

I think maybe the idea of having the permission for an action on a resource is still very central to all the products we support, and it makes sense to keep that.
Maybe just in a "permission bundle" and those can also be grouped?

I think in i.e. GDrive we could give someone read permission on a folder of files, but this relation needs to be already embedded in the application. 
We cannot give someone read access on a group of Trino tables, because this concept does not exist in Trino. 
The group will still need to be maintained outside of Trino, and so we do not have a lot to gain here.

== Design A

RBAC-based design.

Let users define 

== Design B

We design a relation based access control system (ReBAC), inspired by Google Zanzibar.
ReBAC allows for role-based access control as well (RBAC) but goes beyond that to also allow hierarchies of objects that users can be related to.
This allows for more flexibility when defining organizational structures, and rules can be attached at any level.

We define a CustomResource that allows users to define ReBAC stuff in CRs.
This allows for more validation instead of putting rules in a DSL or in JSON into a ConfigMap.

There are three kinds of rules that users can define easily in a CR:

* relations of objects and users
* relations of objects and user sets
* relations of objects and other objects

Users are pre defined in either LDAP or keycloak, and referenced by their name/ID.
Resolving users is done in OPA, using the UserInfoFetcher.
For this ADR, we will assume users are specified by their username, i.e. "alice" or "bob".

Other objects in the system can be entities inside of the products, such as a `trino-table`.
We also allow users to define their own objects and relations, mainly to organize their users and permissions.
Every user-defined object and relation needs to be specified in an RebacType object.

Example:

[source,yaml]
----
kind: RebacType
metadata:
  name: project  # <1>
spec:
  relations:  # <2>
    - name: member
  objects:  # <3>
    - secret-project
    - datascience-spike
    - ladida
    - otherproj
----

<1> The name of the RebacType. This will be referenced in rule definitions.
<2> The relations that are defined for this type. In this case there is a "member" definition. Users can be members of a project.
<3> Object defintions. This is optional; if given, only these objects can be referenced, adding another layer of verification.

For products, the SDP comes with predefined objects that make sense for the product.
For example in Trino we will define `trino-table` and `trino-catalog`, each with a `reader`, `editor` and `owner` relation.
For Superset we can define a `superset-dashboard` with the same relations.
For Kafka we can define a `kafka-topic` type.

We can group some resources together into a project, and then assign users to the project. 
Users can be assigned individually or based on their group memberships.

Here is an example of what it could look like in yaml:

[source,yaml]
----
kind: RebacRelations
metadata:
  name: project-ladida
# Project Ladida manages the mydata table in Trino
# User 13 and all the members of the 'otherproj' project are members 
# of Project Ladida
relations:
  # Which resources are part of the project?
  - subject: "project:ladida"
    relation: "owner"
    object: "trino-table:mydata"
  - subject: "project:ladida"
    relation: "reader"
    object: "kafka-topic:datasource"
  - subject: "project:ladida"
    relation: "editor"
    object: "superset-dashboard:ladida-viz"
  # Who is part of the project?
  - user: "alice"
    relation: "member"
    object: "project:ladida"
  - userset:
      object: "ad-group:datascience"
      relation: "member"
    relation: "member"
    object: "project:ladida"
----

The first three relations define the project as the owner/reader/editor of a number of resources.
Transitively, any member of the project will get these relations.

The last two relations define the user "alice" as a member of the project, as well as any member of the ActiveDirectoy group "datascience".

=== Implementation

The RebacType and RebacRelations can both be annotated with the `opa.stackable.tech/bundle: "true"` label to include it into the OPA bundle.

The relation definitions can the be verified - to a degree - and subsequently everything is serialized as JSON and provided as `data` to OPA.
We then need to define a RegoRule framework inside OPA to evaluate these rules correctly.

== TODO: Gaia-X considerations

TSA? OCM?

"TSA ist OPA, unser Authr. ist OPA, aber bauen wir oder TSA dinge drumherum, die die Integration schwer machen?"

== Appendix

=== Terminology

Resource:: A resource in the authorization context is commonly something that can be accessed, read, edited etc., like a DAG in Airflow, a Table in Trino or a file in a file system. Resources can also be grouped, like a folder in a file system containing multiple files. A resource is specific, so it does not refer to Trino tables in general, but to a specific Foo table (for example).
Action:: An action is defined in context of a resource. Examples are "Viewing", "Editing", "Deleting", "Creating".
Permission:: A permission is the combination of an action and a resource. Like "view table Foo". A permission can also be more general, like "view all tables" (i.e. no specific resource is specified, just a class/type of resource).
Policy:: A policy is a generic term that does not only exist in authorization. It is a rule, like "The cluster should always have 10% free memory left" or "Only the HR team can access the employee database".
RBAC:: Role-based access control.
Role:: A role in RBAC generally means a collection of permissions. In RBAC, permissions are assigned to roles. For example, an _admin_ role might have the permission to view and edit all data. A _marketting-employee_ role grants viewing access to a specific set of tables.
ReBAC:: Relation-based access control.
ABAC:: Attribute-based access control.
Relation:: A relation is pretty generic, and refers to relations between object and and other objects (or resources), between resources and users or between users and other users or user groups. Examples: "Alice is a _reader_ of a table." "Bob is a _member_ of the data science team." "The `pictures` folder is the _parent_ of the `cat.jpg` file."
Group:: A group is typically a collection of users. Groups can also be organized hierarchically. Groups can sometimes be used to attach roles to, so users can simply be grouped together and their permissions be managed as a whole.
