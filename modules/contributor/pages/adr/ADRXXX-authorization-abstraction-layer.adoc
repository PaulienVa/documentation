= ADRXXX: Authorization abstraction layer
Felix Hennig <felix.hennig@stackable.tech>
v0.1, 2024-01-18
:status: draft

* Status: {status}
* Deciders: TBD
* Date: 2024-01-18

Technical Story: https://github.com/stackabletech/issues/issues/439

== Problem Statement

How should we design the user facing part of an authorization layer for the platform? Do we create Custom Resources for some of this? Or simply ConfigMaps? How many, how are the rules split across resources?

== Context

As a user I want to be able to very easily define my access control for everything in the platform.
Access control rules per product should be defined on groups or projects, and then I assign users as members of these groups, departments and projects.
I want to be able to simply say "John is a member of the data science team" and that gives John access to a number of resources in the platform based on his team membership.
I also want to be able to easily specify one-of access to individuals for specific resources, such as given Alice access to a specific Trino table.

=== Different authorization models: RBAC, ABAC, ReBAC and more

Out-of-the-box, OPA uses RegoRules to define policies. 
This is very powerful, but also more complex that other mechanisms such as RBAC or ACLs.
We want to pick an authorization model to build on top of OPA and abstract away from the RegoRules for 95% of use cases that the typical Stackable user might encounter.

Relation-based access control (ReBAC) was popularized by Google Zanzibar and goes beyond RBAC.
The relational model allows for more flexibility when defining rules.

Learn more:

* https://authzed.com/zanzibar
* https://authzed.com/blog/what-is-google-zanzibar
* https://gruchalski.com/posts/2022-05-07-zanzibar-style-acls-with-opa-rego/
* https://www.permit.io/blog/oparebac
* https://www.permit.io/blog/policy-engines

== Decision Drivers

* The design should be flexible to allow to easily represent various organizational structures.
* It should be possible to group together access to different resources across products.
* The design should validate as much of the input as possible, to prevent misspellings from invalidating rules. Nothing should just silently not do anything.
* Rules should be defined as Manifests and put into Kubernetes.

== Constraints

* We use OPA as the underlying policy engine, so any design needs to be implementable with OPA.

== Proposed Design

We design a relation based access control system (ReBAC), inspired by Google Zanzibar.
ReBAC allows for role-based access control as well (RBAC) but goes beyond that to also allow hierarchies of objects that users can be related to.
This allows for more flexibility when defining organizational structures, and rules can be attached at any level.

We define a CustomResource that allows users to define ReBAC stuff in CRs.
This allows for more validation instead of putting rules in a DSL or in JSON into a ConfigMap.

There are three kinds of rules that users can define easily in a CR:

* relations of objects and users
* relations of objects and user sets
* relations of objects and other objects

Users are pre defined in either LDAP or keycloak, and referenced by their name/ID.
Resolving users is done in OPA, using the UserInfoFetcher.
For this ADR, we will assume users are specified by their username, i.e. "alice" or "bob".

Other objects in the system can be entities inside of the products, such as a `trino-table`.
We also allow users to define their own objects and relations, mainly to organize their users and permissions.
Every user-defined object and relation needs to be specified in an RebacType object.

Example:

[source,yaml]
----
kind: RebacType
metadata:
  name: project  # <1>
spec:
  relations:  # <2>
    - name: member
  objects:  # <3>
    - secret-project
    - datascience-spike
    - ladida
    - otherproj
----

<1> The name of the RebacType. This will be referenced in rule definitions.
<2> The relations that are defined for this type. In this case there is a "member" definition. Users can be members of a project.
<3> Object defintions. This is optional; if given, only these objects can be referenced, adding another layer of verification.

For products, the SDP comes with predefined objects that make sense for the product.
For example in Trino we will define `trino-table` and `trino-catalog`, each with a `reader`, `editor` and `owner` relation.
For Superset we can define a `superset-dashboard` with the same relations.
For Kafka we can define a `kafka-topic` type.

We can group some resources together into a project, and then assign users to the project. 
Users can be assigned individually or based on their group memberships.

Here is an example of what it could look like in yaml:

[source,yaml]
----
kind: RebacRelations
metadata:
  name: project-ladida
# Project Ladida manages the mydata table in Trino
# User 13 and all the members of the 'otherproj' project are members 
# of Project Ladida
relations:
  # Which resources are part of the project?
  - subject: "project:ladida"
    relation: "owner"
    object: "trino-table:mydata"
  - subject: "project:ladida"
    relation: "reader"
    object: "kafka-topic:datasource"
  - subject: "project:ladida"
    relation: "editor"
    object: "superset-dashboard:ladida-viz"
  # Who is part of the project?
  - user: "alice"
    relation: "member"
    object: "project:ladida"
  - userset:
      object: "ad-group:datascience"
      relation: "member"
    relation: "member"
    object: "project:ladida"
----

The first three relations define the project as the owner/reader/editor of a number of resources.
Transitively, any member of the project will get these relations.

The last two relations define the user "alice" as a member of the project, as well as any member of the ActiveDirectoy group "datascience".

=== Implementation

The RebacType and RebacRelations can both be annotated with the `opa.stackable.tech/bundle: "true"` label to include it into the OPA bundle.

The relation definitions can the be verified - to a degree - and subsequently everything is serialized as JSON and provided as `data` to OPA.
We then need to define a RegoRule framework inside OPA to evaluate these rules correctly.

== TODO: Gaia-X considerations

TSA? OCM?

"TSA ist OPA, unser Authr. ist OPA, aber bauen wir oder TSA dinge drumherum, die die Integration schwer machen?"

