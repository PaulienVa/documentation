= ADR028: Discovery revision
Sebastian Bernauer <sebastian.bernauer@stackable.tech>
v0.1, 2023-03-30
:status: draft

* Status: {status}
* Contributors:
** Felix Hennig
** Malte Sander
** Natalie Klestrup RÃ¶ijezon
** Sebastian Bernauer
* Date: 2023-02-28

== Context and Problem Statement

// Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate the problem in form of a question.

This ADR is written with a specific problems in mind, but the goal is to reach a generic mechanism for the discovery of products.
The current discovery mechanism is described https://docs.stackable.tech/home/stable/concepts/service_discovery.html[in our docs] (make sure to pick the 23.1 version).

Basically when clients connect to products managed by Stackable, they need to have certain information about how to connect to these products.
Currently we expose some of these information, but not all (e.g. which ca cert the exposed product uses).

== Decision Drivers
We have some common use-cases that we need to express via the discovery mechanism:

1. Trino cluster
* Currently we don't write any discovery CM
* We need at least
** Coordinator address (currently only single coordinator is supported)
*** Ideally split it into the following attributes, so that clients can construct the URI. (trino python client e.g. needs all of these attributes separately and I don't want to rely on parsing and extracting the URI)
**** protocol (http/https)
**** host
**** port
*** In case of https: The SecretClass that provided the cert for the *server*
** What AuthenticationClass must be used to authenticate
*** null (no SecretClass): Means no authentication at all
*** (future) static: One of these plain credentials
*** tls: provides ca.crt that needs to have signed the *client* certificate
*** ldap: <whatever>
*** (future) kerberos: kdc where you can get a ticket from (together with the realm)
*** (future) oauth: <whatever>
*** (future) jwt: <whatever>

2. HDFS cluster
* Currently we expose hdfs-site and core-site
* We need at least
** hdfs-site
** core-site
** What AuthenticationClass must be used to authenticate
*** (future) kerberos: kdc where you can get a ticket from (together with the realm)
** The information about rpc encryption is already in the core-site, so need to expose it explicitly
** The information about data encryption is already in the hdfs-site, so need to expose it explicitly

== Considered Options

=== [1] Discovery Object: Use ConfigMap

Use a ConfigMap:

[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: simple-hdfs
spec:
  data:
    hdfs-site.xml:
    core-site.xml:
    ca.crt: | # Containing a PEM certificate
      === BEGIN CERTIFICATE ===
      XXX
      === END CERTIFICATE ===
    authentication: |
      kerberos:
        secretClass: client-tls # Use this SecretClass to obtain a keytab
    # Alternative solution without yaml enum:
    authenticationType: Kerberos
    authenticationSecretClass: client-kerberos
----

==== Pros

* Easier to use for consuming applications outside of Stackable, as they can simply mount the CM or download it to a file.
  On the other hand when we start to put in yaml objects that need to be parsed we would loose the benefit.

==== Cons

* No complex structure such as enums (we can mitigate this by sticking in custom yaml into the CM).
  Users don't have any form of validation when creating their own discovery CM e.g. pointing to their existing HDFS.

=== [1] Discovery Object: Use dedicated CRD object for every product

Or use a dedicated HdfsClusterDiscovery crd:

[source,yaml]
----
apiVersion: hdfs.stackable.tech/v1alpha1
kind: HdfsClusterDiscovery
metadata:
  name: simple-hdfs
spec:
  hdfs-site.xml: # xml
  core-site.xml: # xml
  httpProtocol:
    http: {}
    # OR
    https:
      caBundle: | # Containing a PEM certificate
        === BEGIN CERTIFICATE ===
        XXX
        === END CERTIFICATE ===
  authentication: |
    kerberos:
      secretClass: client-tls # Use this SecretClass to obtain a keytab
----

==== Pros

==== Cons

* Operator A needs to compile against operator b to have access to it's discovery struct. An alternative would be to put the Discovery CRDs in operator-rs.
* Operator versioning hell. On the other hand we have the same problem with ConfigMaps, as e.g. a newly introduced key is missing because of an older hdfs operator version.

=== [1] Discovery Object: Use dedicated CRD object shared between all products

Or use a dedicated ClusterDiscovery crd:

[source,yaml]
----
apiVersion: discovery.stackable.tech/v1alpha1
kind: ClusterDiscovery
metadata:
  name: simple-hdfs
spec:
  # Whatever
----

==== Pros

* Only one struct in operator-rs -> No cross-operator dependencies.

==== Cons

* It does not seem like it's possible to find a common struct all products can agree upon

=== [1] Discovery Object: Write the discovery to Product CR status

Instead of writing discovery information to dedicated objects - such as CM or custom CR - we "simply" write the discovery information to the status of the Cluster CR.

==== Pros

==== Cons

* It does not enable users to bring their own product and talk to it from Stackable, e.g. a user-provided HDFS.
* It does not allow things such as a ZNode for Zookeeper as we either use the Zookeeper CR for discovery or we use a ZNode but than can't use a Zookeeper CR.
  Currently we have the freedom of either connection to a Zookeeper root dir or a ZNode transparently.

=== [2] TLS: Discovery config contains SecretClass
The discovery includes the SecretClass used to obtain the *server* certificate

Trino discovery:
[source,yaml]
----
metadata:
  name: my-trino
coordinatorEndpoint:
  host: trino-coordinator.ns.svc.cluster.local
  port: 8443
  protocol:
    http: {}
    # OR
    https:
      caCertSecretClass: tls
---
# superset config
security:
  tls:
    secretClassName: tls
  kerberos:
    secretClassName: kerberos
backends: # Don't look at the Superset CRD structure, we are only interested in the tls stuff here
  - name: my-trino
    trino:
      discoveryConfigName: my-trino
----

==== Pros

==== Cons

=== [2] TLS: Client needs to specify SecretClass
---
The discovery does *not* include the SecretClass used to obtain the *server* certificate.
Instead the client must specify which SecretClass should be used to verify the *server* certificate.
For usability reasons it can be omitted and defaults to the SecretClass the client uses for itself.

Trino discovery:
[source,yaml]
----
metadata:
  name: my-trino
coordinatorEndpoint: https://trino-coordinator.ns.svc.cluster.local:8443
---
# superset config
security:
  tls:
    secretClassName: tls
  kerberos:
    secretClassName: kerberos
backends: # Don't look at the Superset CRD structure, we are only interested in the tls stuff here
  - name: my-trino
    trino:
      discoveryConfigName: my-trino
      # override tls from the global config, OPTIONALLY
      tlsSecretClass: my-second-pki
----

==== Pros

* Operator does not need to read/look at the DiscoveryConfig (as we can statically set up the secret-op tls secretClass volumes rather than retrieving them from the DiscoveryConfig).
* Some clients only support a single pki, in that case we could not give the ability to overwrite the secretClass coming from the product itself.

==== Cons

* The client has to know what pki/secretClass the server is using.

=== [2] TLS: Include caCert in Discovery config

Trino discovery:
[source,yaml]
----
metadata:
  name: my-trino
endpoint:
  host: trino-coordinator.ns.svc.cluster.local
  port: 8443
  protocol:
    http: {}
    # OR
    https:
      caBundle: | # Containing a PEM certificate
        === BEGIN CERTIFICATE ===
        XXX
        === END CERTIFICATE ===
----

==== Pros

* Assuming DiscoveryConfig is located within a CM, the operator can simply mount the discovery CM to get the ca.crt.  Operator does not need to read/look at the DiscoveryConfig.
* Easier for external clients to use as they don't need to know the concept of SecretClasses and don't even need to run withing k8s.
* The client has to *not* know what pki/secretClass the server is using.

==== Cons

* BIG QUESTION: How should the product operator get the ca cert from the SecretClass it uses to get the *server* cert from?
** The secret-op could e.g. offer an HTTP api to fetch the ca.crt of a given SecretClass or e.g. write the ca.crt into the status of a SecretClass


=== [3] Authentication: Add AuthenticationClass to Discovery Config

Trino discovery:
[source,yaml]
----
metadata:
  name: my-trino
authentication:
  authenticationClass: my-class
----

==== Cons

* Operator has to read the AuthenticationClass to determine its type (pw/tls/keytab) and set up the needed volumes and commands.
* The AuthenticationClass is meant to describe "how should a server verify connecting clients" and re-purpose it to mean "how a client should authenticate itself".


=== [3] Authentication: Add SecretClass to Discovery Config

Trino discovery:
[source,yaml]
----
metadata:
  name: my-trino
authentication:
  secretClass: client-tls # Use this SecretClass to obtain your credentials (regardless of type of SecretClass)
----

==== Cons

* Operator has to read the SecretClass to determine its type (pw/tls/keytab) and set up the needed volumes and commands.


=== [3] Authentication: Add needed details

Trino discovery:
[source,yaml]
----
metadata:
  name: my-trino
authentication:
  none: {}
  password: {}
  tls:
    secretClass: client-tls # Use this SecretClass to obtain a *client* cert
  kerberos:
    secretClass: client-kerberos # Use this SecretClass to obtain a keytab
  oauth:
    secretClass: client-oauth # Use this SecretClass to obtain whatever it needs
----

==== Pros

* Operator has *not* to read the SecretClass to determine its type (pw/tls/keytab), as the type is already encoded in the Discovery config.

==== Cons

* Operator has read the Discovery CM it wants to connect to

== Decision Outcome

[1] Discovery Object: TODO
[2] TLS: TODO
[3] Authentication: TODO

=== Appendix A
Let's model a kerberos secured HDFS with the Options "TLS: Include caCert in Discovery config" and "Authentication: Add needed details"

[source,yaml]
----
apiVersion: hdfs.stackable.tech/v1alpha1
kind: HdfsCluster
metadata:
  name: simple-hdfs
spec:
  zookeeperConfigMapName: simple-hdfs-znode
  nameNodes: {}
  dataNodes: {}
  journalNodes: {}
  # TODO Refine CRD
  kerberos:
    tlsSecretClass: tls
    kerberosSecretClass: kerberos
    wireEncryption: Privacy
----
